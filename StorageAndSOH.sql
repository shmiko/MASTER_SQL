SELECT SH_ORDER, SH_CUST, SH_NOTE_1, SH_NOTE_2 , SH_NUM_LINES,SH_SPARE_DBL_9, SH_ADD_DATE,SH_ADD_TIME, SH_LAST_PICK_NUM, SH_STATUS, Count(ROWNUM) AS "NumberOfOrders",SD_STOCK,SD_QTY_ORDER,IM_STOCK, IL_IN_LOCN, NI_LOCN, NI_QUANTITY,NI_AVAIL_ACTUAL, NI_STATUS, NI_STRENGTH, IM_DESC, NI_DATE, NI_MADE_DATE, NI_QUARANTINED, NI_ENTRY, NI_QJ_NUMBER, NI_QD_DES_SEQ, NI_TRAN_TYPE, NI_ID  
FROM NI, IM, IL, SH, SD
WHERE  (NI_AVAIL_ACTUAL > 1) AND ((NI_STATUS = 1) OR (NI_STATUS = 2))
AND NI_STOCK = IM_STOCK
AND SH_ORDER = SD_ORDER
AND NI_LOCN = IL_LOCN
AND IM_STOCK = SD_STOCK
AND SH_ADD_DATE >= '1-Jul-2013' AND SH_ADD_DATE <= '11-Jul-2013'
AND SH_STATUS = 0 AND SD_STATUS = 0
GROUP BY SH_ORDER, SH_CUST, SH_NOTE_1, SH_NOTE_2 , SH_NUM_LINES,SH_SPARE_DBL_9, SH_ADD_DATE,SH_ADD_TIME, SH_LAST_PICK_NUM, SH_STATUS, ROWNUM,SD_STOCK,SD_QTY_ORDER,IM_STOCK, IL_IN_LOCN, NI_LOCN, NI_QUANTITY,NI_AVAIL_ACTUAL, NI_STATUS, NI_STRENGTH, IM_DESC, NI_DATE, NI_MADE_DATE, NI_QUARANTINED, NI_ENTRY, NI_QJ_NUMBER, NI_QD_DES_SEQ, NI_TRAN_TYPE, NI_ID  


var cust varchar2(20)
exec :cust := 'TABCORP'
/*Used for getting EOM storage lines*/           /*OK as of Nov 2012    */


SELECT DISTINCT l.IL_LOCN, Count(n1.NI_STOCK) AS "LocnCount",l.IL_NOTE_2,  
                  CASE   WHEN l.IL_NOTE_2 like 'Yes' OR l.IL_NOTE_2 LIKE 'YES' OR l.IL_NOTE_2 LIKE 'yes' THEN 'Pallet Fee is for stocks ' ||  i2.IM_STOCK
                        WHEN l.IL_NOTE_2 NOT like 'No' OR l.IL_NOTE_2 NOT LIKE 'YES' OR l.IL_NOTE_2 NOT LIKE 'yes' THEN 'Shelf Fee is '  ||  i2.IM_STOCK
                        ELSE ''
                        END AS "FeeDescription",
                  CASE   WHEN l.IL_NOTE_2 like 'Yes' OR l.IL_NOTE_2 LIKE 'YES' OR l.IL_NOTE_2 LIKE 'yes' THEN '' || (Select RM_XX_FEE11 from RM where RM_CUST = :cust  ) / Count(n1.NI_STOCK)
                        WHEN l.IL_NOTE_2 NOT like 'No' OR l.IL_NOTE_2  NOT LIKE 'YES' OR l.IL_NOTE_2 NOT LIKE 'yes' THEN '' || (Select RM_XX_FEE12 from RM where RM_CUST = :cust ) / Count(n1.NI_STOCK)
                        ELSE ''
                        END AS "Fee" , Sum(n1.NI_AVAIL_ACTUAL) AS "TotalAvail"
FROM PWIN175.IL l 
 RIGHT OUTER JOIN PWIN175.NI n1 ON n1.NI_LOCN = l.IL_LOCN
 INNER JOIN PWIN175.IM i2 ON i2.IM_STOCK = n1.NI_STOCK 
WHERE   n1.NI_AVAIL_ACTUAL >= '1'               
--AND i2.IM_CUST = :cust
AND l.IL_LOCN IN ( 

                  SELECT  n2.NI_LOCN
                  FROM    PWIN175.NI n2 --INNER JOIN PWIN175.IM i ON i.IM_STOCK = n2.NI_STOCK
                  WHERE   n2.NI_AVAIL_ACTUAL >= '1'
                 -- AND i.IM_CUST = :cust
                  AND n2.NI_LOCN = 'MR340A'
                  AND n2.NI_STOCK IN (
                                      SELECT i3.IM_STOCK FROM PWIN175.IM i3 WHERE i3.IM_CUST = :cust
                                      )
                 )

GROUP BY l.IL_LOCN, l.IL_NOTE_2, i2.IM_STOCK
ORDER BY l.IL_LOCN



SELECT l.IL_LOCN, Count(i.IM_STOCK) AS "LocnCount",i.IM_STOCK,  
                  CASE  WHEN l.IL_NOTE_2 like 'Yes' OR l.IL_NOTE_2 LIKE 'YES' OR l.IL_NOTE_2 LIKE 'yes' THEN 'Pallet Fee is for stocks ' ||  i.IM_STOCK
                        WHEN l.IL_NOTE_2 NOT like 'No' OR l.IL_NOTE_2 NOT LIKE 'YES' OR l.IL_NOTE_2 NOT LIKE 'yes' THEN 'Shelf Fee is '  ||  i.IM_STOCK
                        ELSE ''
                        END AS "FeeDescription",
                  CASE  WHEN l.IL_NOTE_2 like 'Yes' OR l.IL_NOTE_2 LIKE 'YES' OR l.IL_NOTE_2 LIKE 'yes' THEN '' || (Select RM_XX_FEE11 from RM where RM_CUST = :cust  ) / Count(n1.NI_STOCK)
                        WHEN l.IL_NOTE_2 NOT like 'No' OR l.IL_NOTE_2  NOT LIKE 'YES' OR l.IL_NOTE_2 NOT LIKE 'yes' THEN '' || (Select RM_XX_FEE12 from RM where RM_CUST = :cust ) / Count(n1.NI_STOCK)
                        ELSE ''
                        END AS "Fee" , Sum(n1.NI_AVAIL_ACTUAL) AS "TotalAvail"
FROM PWIN175.NI n1 
 INNER JOIN PWIN175.IM i ON i.IM_STOCK = n1.NI_STOCK
 LEFT OUTER JOIN PWIN175.IL l ON l.IL_LOCN = n1.NI_LOCN
 INNER JOIN PWIN175.RM r ON R.RM_CUST = i.IM_CUST 
 INNER JOIN PWIN175.I l2 ON l2.IL_LOCN = l.IL_LOCN
WHERE   n1.NI_AVAIL_ACTUAL >= '1'
AND l.IL_LOCN = l2.IL_LOCN
AND i.IM_CUST = :cust

GROUP BY i.IM_STOCK,l.IL_LOCN, l.IL_NOTE_2            
--
AND l.IL_LOCN IN ( 

                  SELECT  n2.NI_LOCN
                  FROM    PWIN175.NI n2 --INNER JOIN PWIN175.IM i ON i.IM_STOCK = n2.NI_STOCK
                  WHERE   n2.NI_AVAIL_ACTUAL >= '1'
                 -- AND i.IM_CUST = :cust
                  AND n2.NI_LOCN = 'MR340A'
                  AND n2.NI_STOCK IN (
                                      SELECT i3.IM_STOCK FROM PWIN175.IM i3 WHERE i3.IM_CUST = :cust
                                      )
                 )

GROUP BY i2.IM_STOCK, l.IL_NOTE_2
ORDER BY l.IL_LOCN









SELECT  NI_ENTRY, NI_TRAN_TYPE,NI_STATUS,NI_ERA, NI_QUANTITY, NE_AVAIL_ACTUAL, IL_LOCN, IM_STOCK, IM_CUST, IL_NOTE_2 , Sum(NE_AVAIL_ACTUAL) AS "TotalSOH", Count(IL_LOCN) AS "NumOfLocns",
NI_DATE, NE_DATE,NE_STATUS,NE_ERA, NE_STRENGTH, NI_AVAIL_ACTUAL, NI_LOCN, NE_STOCK, NE_QUANTITY, NE_ACCOUNT,NE_NA_EXT_KEY, NE_NV_EXT_TYPE,NE_NV_EXT_KEY,NE_MOVEMENT, 
  CASE   WHEN IL.IL_NOTE_2 like 'Yes' THEN 'Pallet Fee is '
         WHEN IL.IL_NOTE_2 NOT like 'No'  THEN 'Shelf Fee is '
         ELSE ''
         END AS "FeeDescription",
  CASE   WHEN IL.IL_NOTE_2 like 'Yes' THEN '' || (Select RM_XX_FEE11 from RM where RM_CUST = :cust)
         WHEN IL.IL_NOTE_2 NOT like 'No' THEN  '' || (Select RM_XX_FEE12 from RM where RM_CUST = :cust)
         ELSE ''
         END AS "Fee"
FROM PWIN175.NI, PWIN175.NE, PWIN175.IL, PWIN175.IM , PWIN175.RM r
WHERE IL_LOCN = NI_LOCN
AND NI_ENTRY = NE_ENTRY
AND NI_STOCK = IM_STOCK
AND RM_CUST = IM_CUST
--WHERE r.RM_SOURCE = :source
AND RM_CUST = :cust           
AND IM_STOCK IN (
                  SELECT  n.NI_STOCK
                  FROM PWIN175.NI n --INNER JOIN PWIN175.IL l ON l.IL_LOCN = n.NI_LOCN
                  WHERE n.NI_AVAIL_ACTUAL >= '1' 
                )
GROUP BY NI_ENTRY, NI_TRAN_TYPE,NI_STATUS,NI_ERA, NI_QUANTITY, NE_AVAIL_ACTUAL, IL_LOCN, IM_STOCK, IM_CUST,IL_NOTE_2,NI_DATE, 
NE_DATE,NE_STATUS,NE_ERA, NE_STRENGTH, NI_AVAIL_ACTUAL, NI_LOCN, NE_STOCK, NE_QUANTITY, NE_ACCOUNT,NE_NA_EXT_KEY, NE_NV_EXT_TYPE,NE_NV_EXT_KEY,NE_MOVEMENT, NE_PRICE_ENTRY, NE_COST_ENTRY,IL_NOTE_2

ORDER BY NI_LOCN, IM_STOCK









SELECT  l.IL_LOCN,
        l.IL_NOTE_2,
        null,
        Sum(e.NE_AVAIL_ACTUAL) AS "TotalSOH", 
        Count(n.NI_STOCK) AS "LocationCount"
        --a.NA_EXT_TYPE
        ,
       CASE   WHEN l.IL_NOTE_2 like 'Yes' OR l.IL_NOTE_2 LIKE 'YES' OR l.IL_NOTE_2 LIKE 'yes' THEN 'Pallet Fee is for stocks ' ||  i.IM_STOCK
              WHEN l.IL_NOTE_2 NOT like 'No' OR l.IL_NOTE_2 NOT LIKE 'YES' OR l.IL_NOTE_2 NOT LIKE 'yes' THEN 'Shelf Fee is '  ||  i.IM_STOCK
              ELSE ''
              END AS "FeeDescription",
        CASE   WHEN l.IL_NOTE_2 like 'Yes' OR l.IL_NOTE_2 LIKE 'YES' OR l.IL_NOTE_2 LIKE 'yes' THEN '' || (Select RM_XX_FEE11 from RM where RM_CUST = :cust  ) --/ Count(n1.NI_STOCK)
              WHEN l.IL_NOTE_2 NOT like 'No' OR l.IL_NOTE_2  NOT LIKE 'YES' OR l.IL_NOTE_2 NOT LIKE 'yes' THEN '' || (Select RM_XX_FEE12 from RM where RM_CUST = :cust ) --/ Count(n1.NI_STOCK)
              ELSE ''
              END AS "Fee" 
FROM    IM i  --,IL l, NE e, NI n, NA a
        INNER JOIN NE e ON e.NE_STOCK = i.IM_STOCK
        INNER JOIN NI n ON n.NI_ENTRY = e.NE_ENTRY --AND a.NA_EXT_TYPE = 1810105
        INNER JOIN IL l ON l.IL_LOCN = n.NI_LOCN 
        INNER JOIN RM r ON r.RM_CUST = i.IM_CUST
WHERE   e.NE_AVAIL_ACTUAL >= '1' 
AND     RM_CUST = :cust 
GROUP BY  l.IL_LOCN, l.IL_NOTE_2, i.IM_STOCK,e.NE_AVAIL_ACTUAL


SELECT   n.NI_LOCN, Count(n.NI_STOCK) "StockNum"  
FROM NI n 
WHERE   n.NI_AVAIL_ACTUAL >= '1' 
AND n.NI_STOCK IN (SELECT i.IM_STOCK FROM IM i WHERE i.IM_CUST = :cust AND i.IM_STOCK = n.NI_STOCK )
AND n.NI_LOCN IS NOT NULL
GROUP BY  n.NI_LOCN , n.NI_STOCK

UNION ALL

SELECT   n2.NI_STOCK, n2.NI_LOCN, Count(n2.NI_STOCK) "StockNum"  
FROM NI n2 
WHERE   n2.NI_AVAIL_ACTUAL >= '1' 
AND n2.NI_STOCK IN (SELECT i2.IM_STOCK FROM IM i2 WHERE i2.IM_CUST = :cust AND i2.IM_STOCK = n2.NI_STOCK )
AND n2.NI_LOCN IS NOT NULL
GROUP BY  n2.NI_STOCK,n2.NI_LOCN  



-- NE Table is the new INVENTORY Table for PrismIQ v 2010.9.2
-- All AUTOMATED TRANSACTIONS will have a corresponding NE
SELECT * FROM pwin175.NE
WHERE NE_ADD_DATE > = '10-APR-2011'



-- IT Table is another INVENTORY Table for PrismIQ v 2010.9.2
-- All MANUAL TRANSACTIONS (Transfer, Stocktake, Manual Receipts) will have a corresponding IT
SELECT * FROM pwin175.IT
WHERE IT_ADD_DATE > = '10-APR-2011'



/* GOOD ONE FOR JASON DESPATCHES WITH COUNTS */
USE PWIN171
SELECT ST_ORDER, SH_CUST, ST_PICK, ST_DESP_DATE, COUNT(*) AS "NUMLINE"
FROM ST, SD, SH
WHERE SD_ORDER = SH_ORDER
/* AND LTRIM(RTRIM(ST_ORDER)) = '202759'  */
AND SH_ORDER = ST_ORDER
AND LTRIM(RTRIM(ST_PICK)) = LTRIM(RTRIM(SD_LAST_PICK_NUM))
/* AND SD_LAST_PSLIP_NUM <> '' */
/* AND SH_CUST NOT LIKE('01-9%') */
AND SH_CUST <> '01-990200'
AND SH_CUST <> '01-910001'
AND SD_STOCK NOT LIKE('CPL%') 
AND SD_STOCK NOT LIKE ('FREIGHT%')
AND SD_STOCK <> 'ORDER'
AND ST_DESP_DATE >= '01-JUL-06'
/* AND ST_DESP_DATE < '03-JUL-07' */
AND ST_DESP_DATE <= '31-MAR-07' 
GROUP BY ST_PICK, ST_ORDER, SH_CUST, ST_DESP_DATE
ORDER BY ST_DESP_DATE

/* GOOD ONE FOR JASON DESPATCHES WITH COUNTS */
USE PWIN171
SELECT SD_STOCK, ST_DESP_DATE, COUNT(*) AS "NUMLINE"
FROM ST, SD, SH
WHERE SD_ORDER = SH_ORDER 
/* AND SD_LAST_PSLIP_NUM = ST_PSLIP */
/* AND LTRIM(RTRIM(ST_ORDER)) = '202759'  */
AND SH_ORDER = ST_ORDER
AND LTRIM(RTRIM(ST_PICK)) = LTRIM(RTRIM(SD_LAST_PICK_NUM))
/* AND SD_LAST_PSLIP_NUM <> '' */
/* AND SH_CUST NOT LIKE('01-9%') */
AND SH_CUST LIKE '01-CML%'
AND SD_STOCK NOT LIKE('CPL%') 
AND SD_STOCK NOT LIKE ('FREIGHT%')
AND SD_STOCK <> 'ORDER'
AND ST_DESP_DATE >= '01-JAN-05'
/* AND ST_DESP_DATE < '03-JUL-07' */
AND ST_DESP_DATE <= '31-MAR-05' 
GROUP BY SD_STOCK, ST_PICK, ST_ORDER, SH_CUST, ST_DESP_DATE
ORDER BY ST_DESP_DATE


SELECT DISTINCT SD_STOCK, SUM(SL_PSLIP_QTY) "QTY DESP", 
SUM(CASE WHEN DATEPART(MONTH, [ST_DESP_DATE]) = 1 THEN 1 ELSE 0 END) AS [Jan],
SUM(CASE WHEN DATEPART(MONTH, [ST_DESP_DATE]) = 2 THEN 1 ELSE 0 END) AS [Feb],
SUM(CASE WHEN DATEPART(MONTH, [ST_DESP_DATE]) = 3 THEN 1 ELSE 0 END) AS [Mar],
SUM(CASE WHEN DATEPART(MONTH, [ST_DESP_DATE]) = 4 THEN 1 ELSE 0 END) AS [Apr],
SUM(CASE WHEN DATEPART(MONTH, [ST_DESP_DATE]) = 5 THEN 1 ELSE 0 END) AS [May],
SUM(CASE WHEN DATEPART(MONTH, [ST_DESP_DATE]) = 6 THEN 1 ELSE 0 END) AS [Jun],
SUM(CASE WHEN DATEPART(MONTH, [ST_DESP_DATE]) = 7 THEN 1 ELSE 0 END) AS [Jul],
SUM(CASE WHEN DATEPART(MONTH, [ST_DESP_DATE]) = 8 THEN 1 ELSE 0 END) AS [Aug],
SUM(CASE WHEN DATEPART(MONTH, [ST_DESP_DATE]) = 9 THEN 1 ELSE 0 END) AS [Sep],
SUM(CASE WHEN DATEPART(MONTH, [ST_DESP_DATE]) = 10 THEN 1 ELSE 0 END) AS [Oct],
SUM(CASE WHEN DATEPART(MONTH, [ST_DESP_DATE]) = 11 THEN 1 ELSE 0 END) AS [Nov],
SUM(CASE WHEN DATEPART(MONTH, [ST_DESP_DATE]) = 12 THEN 1 ELSE 0 END) AS [Dec]
FROM SD, SL , ST, SH
WHERE [ST_DESP_DATE] >= '01-JAN-05' AND [ST_DESP_DATE] <= '31-JAN-05'
AND SH_CUST LIKE '01-CML%'
AND SD_ORDER = SL_ORDER 
AND SH_ORDER = ST_ORDER
AND LTRIM(RTRIM(ST_PICK)) = LTRIM(RTRIM(SD_LAST_PICK_NUM))
AND SD_STOCK = 'KMA36407750'
GROUP BY SD_STOCK, ST_DESP_DATE
ORDER BY ST_DESP_DATE


/**** Jobs which need to be closed -- for Gloria
were opened to despach, have a chargeout indicating job to be closed ****/ 
SELECT SD_STOCK, SUM(SL_PSLIP_QTY) "QTY DESP"
FROM SD, SL , ST, SH
WHERE [ST_DESP_DATE] >= '01-JAN-05' AND [ST_DESP_DATE] <= '31-MAR-05'
AND SH_CUST LIKE '01-CML%'
AND SD_ORDER = SL_ORDER 
AND SH_ORDER = ST_ORDER
AND LTRIM(RTRIM(ST_PICK)) = LTRIM(RTRIM(SD_LAST_PICK_NUM))
GROUP BY SD_STOCK, ST_DESP_DATE
ORDER BY ST_DESP_DATE



WHERE (QM_JOB_STATUS <> 12 AND QM_JOB_STATUS <> 13)
AND (LTRIM(RTRIM(QD_RESERVED_CHARS)) <> 'SAMPLES')
AND QM_NUMBER = QD_JOB_NUM
AND QM_NUMBER IN
(select	DISTINCT QM_NUMBER FROM QM, QO
WHERE QM_NUMBER = QO_JOB_NUM 
AND QO_CLOSE = 1)
GROUP BY QM_NUMBER, QM_JOB_QTY, QM_QTY_DESP
HAVING (SUM(QD_DES_QTY) > QM_JOB_QTY)


/* TRAN_NO_PRICE  - where costprice is null*/
select IT_BATCH, IT_TRAN, IT_CUST, IT_STOCK, IM_OWNED_BY, IT_COST_PRICE, 
CASE 
	WHEN IT_TRAN_TYPE = 2 THEN 'STOCKTAKE'
	WHEN IT_TRAN_TYPE = 4 THEN 'TRANSFER'
	WHEN IT_TRAN_TYPE = 5 THEN 'ADJUSTMENT' 
END AS IT_TRAN_TYPE 
, IT_DATE
from IT, IM
where IT_STOCK = IM_STOCK
AND IM_OWNED_BY = 0
AND IT_COST_PRICE = 0
AND IT_TRAN_TYPE IN (2,4,5)
/* AND IT_DATE = '26-MAR-2006'; */
AND IT_DATE BETWEEN '26-MAR-2006' AND '26-JUNE-2006'
;
